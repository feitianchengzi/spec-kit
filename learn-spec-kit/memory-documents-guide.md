# Memory 文档系统指南

## 概述

Memory 目录是 spec-kit 项目的核心记忆系统，包含了项目的"宪法"和治理文档。这些文档定义了项目的非协商性原则、开发规范和治理规则，为整个 spec-driven 开发流程提供指导。

## 目录结构

```
memory/
└── constitution.md                    # 项目宪法 - 核心原则和规范
```

## 核心文档详解

### 1. constitution.md - 项目宪法

**作用**: 定义项目的核心原则和不可协商的开发规范。

#### 文档结构

```markdown
# [PROJECT_NAME] Constitution

## Core Principles
### [PRINCIPLE_1_NAME] - 核心原则1
### [PRINCIPLE_2_NAME] - 核心原则2
### [PRINCIPLE_3_NAME] - 核心原则3
### [PRINCIPLE_4_NAME] - 核心原则4
### [PRINCIPLE_5_NAME] - 核心原则5

## [SECTION_2_NAME] - 附加约束
## [SECTION_3_NAME] - 开发工作流
## Governance - 治理规则
```

#### 核心原则模板

文档提供了7个核心原则的模板结构：

1. **原则1 - Library-First（库优先）**
   - 每个功能都从独立库开始
   - 库必须自包含、独立可测试、有文档
   - 需要明确目的，不允许仅组织性的库

2. **原则2 - CLI Interface（CLI 接口）**
   - 每个库都通过 CLI 暴露功能
   - 文本输入/输出协议：stdin/args → stdout，错误 → stderr
   - 支持 JSON 和人类可读格式

3. **原则3 - Test-First（测试优先，不可协商）**
   - TDD 强制要求：测试编写 → 用户批准 → 测试失败 → 然后实现
   - 严格执行红-绿-重构循环

4. **原则4 - Integration Testing（集成测试）**
   - 需要集成测试的重点领域：
     - 新库合约测试
     - 合约变更
     - 服务间通信
     - 共享模式

5. **原则5 - Observability（可观测性）**
   - 文本 I/O 确保可调试性
   - 需要结构化日志记录

6. **原则6 - Versioning & Breaking Changes（版本控制和破坏性变更）**
   - MAJOR.MINOR.BUILD 格式
   - 破坏性变更需要迁移计划

7. **原则7 - Simplicity（简洁性）**
   - 从简单开始，遵循 YAGNI 原则
   - 避免过度设计

#### 治理规则

- **宪法至上**: 宪法超越所有其他实践
- **修订要求**: 修订需要文档、批准、迁移计划
- **合规验证**: 所有 PR/审查必须验证合规性
- **复杂性证明**: 复杂性必须被证明合理

#### 版本信息

```markdown
**Version**: [CONSTITUTION_VERSION] | **Ratified**: [RATIFICATION_DATE] | **Last Amended**: [LAST_AMENDED_DATE]
```

### 2. 宪法更新机制

**作用**: 通过 `/constitution` 命令创建或更新项目宪法，确保宪法内容的完整性和一致性。

#### 主要功能

1. **宪法内容管理**
   - 基于模板创建或更新宪法文件
   - 自动填充占位符和版本信息
   - 确保宪法结构的完整性

2. **版本控制**
   - 自动管理宪法版本号
   - 记录批准和修订日期
   - 维护宪法变更历史

#### 宪法更新流程

##### 1. 使用 `/constitution` 命令

**命令执行**:
- 加载现有宪法模板
- 识别所有占位符标记
- 收集或推导具体值
- 填充模板内容

##### 2. 版本管理

**版本号规则**:
- MAJOR: 向后不兼容的治理/原则移除或重新定义
- MINOR: 新增原则/部分或实质性扩展指导
- PATCH: 澄清、措辞、拼写修复、非语义性改进

##### 3. 内容验证

**宪法内容检查**:
- 所有占位符都被替换
- 版本行匹配报告
- 日期格式正确 (YYYY-MM-DD)
- 原则声明明确、可测试

##### 4. 同步影响报告

**自动生成报告**:
- 版本变更: 旧版本 → 新版本
- 修改的原则列表
- 新增/移除的部分
- 需要更新的模板文件

## 使用工作流

### 1. 项目初始化

当创建新项目时：

1. **复制宪法模板**:
   ```bash
   # 通过 /constitution 命令创建宪法文件
   ```

2. **自定义宪法内容**:
   - 替换 `[PROJECT_NAME]` 为实际项目名称
   - 填写具体的核心原则描述
   - 添加项目特定的约束和工作流

3. **设置版本信息**:
   - 设置初始版本号
   - 记录批准日期
   - 建立修订历史

### 2. 宪法修订流程

当需要修改宪法时：

1. **准备修订**:
   - 明确修订原因和目标
   - 评估对现有项目的影响
   - 准备迁移计划

2. **执行更新检查清单**:
   - 使用 `/constitution` 命令进行宪法更新
   - 更新所有相关模板
   - 验证一致性

3. **测试和验证**:
   - 运行示例实现计划
   - 确保所有要求都得到满足
   - 检查文档间的一致性

4. **提交和记录**:
   - 更新版本号
   - 记录修订日期
   - 更新同步状态

### 3. 日常使用

在开发过程中：

1. **参考宪法原则**:
   - 在编写规范时遵循核心原则
   - 在制定计划时考虑宪法要求
   - 在生成任务时应用治理规则

2. **合规检查**:
   - 确保所有 PR 符合宪法要求
   - 在代码审查中验证合规性
   - 定期检查模板同步状态

## 最佳实践

### 1. 宪法设计

- **保持简洁**: 原则应该清晰、简洁、易于理解
- **避免冲突**: 确保原则之间没有矛盾
- **考虑实用性**: 原则应该能够实际执行
- **版本控制**: 使用语义化版本控制

### 2. 更新管理

- **渐进式更新**: 避免大幅修改，采用渐进式更新
- **影响评估**: 每次更新前评估对现有项目的影响
- **文档同步**: 确保所有相关文档保持同步
- **测试验证**: 更新后通过实际项目验证

### 3. 团队协作

- **明确沟通**: 宪法变更需要团队明确沟通
- **培训支持**: 为新原则提供培训和文档
- **反馈机制**: 建立反馈机制收集使用体验
- **定期审查**: 定期审查宪法的有效性和适用性

## 与其他系统的集成

### 1. 模板系统

宪法与模板系统紧密集成：
- 所有模板都引用宪法原则
- 模板更新需要同步宪法变更
- 宪法变更需要更新相关模板

### 2. 脚本系统

脚本系统帮助执行宪法要求：
- `update-agent-context.sh` 可以更新宪法引用
- 脚本可以验证宪法合规性
- 自动化工具可以检查同步状态

### 3. AI 代理系统

AI 代理使用宪法作为指导：
- Claude Code 通过 `CLAUDE.md` 引用宪法
- Gemini CLI 通过 `GEMINI.md` 应用宪法原则
- GitHub Copilot 通过指令文件遵循宪法

## 故障排除

### 常见问题

1. **宪法与模板不同步**:
   - 使用检查清单逐步同步
   - 检查版本号是否一致
   - 验证所有引用是否正确

2. **原则冲突**:
   - 重新审视原则的优先级
   - 考虑合并或重新表述
   - 寻求团队共识

3. **执行困难**:
   - 检查原则是否过于复杂
   - 考虑提供更多指导文档
   - 简化或分解复杂原则

### 维护建议

1. **定期审查**: 每季度审查宪法的有效性
2. **版本管理**: 使用语义化版本控制
3. **文档同步**: 建立自动化检查机制
4. **团队培训**: 定期培训团队使用宪法

## 扩展和自定义

### 1. 添加新原则

1. 在宪法中添加新原则
2. 更新检查清单
3. 修改相关模板
4. 更新 AI 代理指令

### 2. 领域特定定制

不同项目类型可能需要不同的宪法：
- **Web 项目**: 强调 API 设计和前端集成
- **CLI 工具**: 强调命令行接口和用户体验
- **库项目**: 强调 API 稳定性和文档

### 3. 组织级宪法

大型组织可以建立组织级宪法：
- 定义跨项目的通用原则
- 建立项目间的一致性标准
- 提供共享的治理框架

Memory 文档系统是 spec-kit 项目的核心治理机制，通过宪法和检查清单确保项目的一致性和质量。正确使用这些文档可以显著提高开发效率和代码质量。
